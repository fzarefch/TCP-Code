#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <netdb.h>
#include <pthread.h>
#include <pcap.h>

#define MAX_BUFFER 256
#define PCAP_FILE "netzwerkverkehr.pcap"
#define LOG_FILE "netzwerkverkehr.log"

void fehler(const char *msg) {
    perror(msg);
    exit(1);
}

typedef struct {
    pcap_t *handle;
    pcap_dumper_t *dumper;
} PcapData;

void *netzwerkverkehr_aufzeichnen(void *arg) {
    PcapData *pcapData = (PcapData *)arg;
    pcap_t *handle = pcapData->handle;
    pcap_dumper_t *dumper = pcapData->dumper;

    struct pcap_pkthdr header;
    const unsigned char *packet;

    int paketzähler = 0;

    while (paketzähler < 100) {
        packet = pcap_next(handle, &header);
        if (packet == NULL) {
            continue;
        }

        pcap_dump((unsigned char *)dumper, &header, packet);

        paketzähler++;
    }

    pcap_dump_close(dumper);
    pcap_close(handle);

    printf("Aufgezeichneter Netzwerkverkehr wurde in %s gespeichert\n", PCAP_FILE);

    return NULL;
}

void menü_anzeigen() {
    printf("\n\n1. Nachricht senden (TCP)\n");
    printf("2. Nachricht senden (UDP)\n");
    printf("3. Netzwerkverkehr aufzeichnen\n");
    printf("4. Nachrichten lesen\n");
    printf("5. Beenden\n");
    printf("Bitte wählen Sie: ");
}

int main(int argc, char *argv[]) {
    int sockfd, portno, n, auswahl;
    struct sockaddr_in serv_addr;
    struct hostent *server;
    char buffer[MAX_BUFFER];

    if (argc < 3) {
        fprintf(stderr, "Verwendung: %s hostname port\n", argv[0]);
        exit(1);
    }

    portno = atoi(argv[2]);
    sockfd = socket(AF_INET, SOCK_STREAM, 0);
    if (sockfd < 0) {
        fehler("FEHLER beim Öffnen des Sockets");
    }

    server = gethostbyname(argv[1]);
    if (server == NULL) {
        fprintf(stderr, "FEHLER, kein solcher Host\n");
        exit(1);
    }

    bzero((char *)&serv_addr, sizeof(serv_addr));
    serv_addr.sin_family = AF_INET;
    bcopy((char *)server->h_addr, (char *)&serv_addr.sin_addr.s_addr, server->h_length);
    serv_addr.sin_port = htons(portno);

    if (connect(sockfd, (struct sockaddr *)&serv_addr, sizeof(serv_addr)) < 0) {
        fehler("FEHLER bei der Verbindung");
    }

    pthread_t pcapThread;
    PcapData pcapData;
    pcapData.handle = pcap_open_live("any", 65536, 1, 1000, buffer);
    if (pcapData.handle == NULL) {
        fprintf(stderr, "Konnte den pcap-Handle nicht öffnen: %s\n", buffer);
        exit(1);
    }

    pcapData.dumper = pcap_dump_open(pcapData.handle,PCAP_FILE);
if (pcapData.dumper == NULL) {
fprintf(stderr, "Konnte die pcap-Dump-Datei nicht öffnen\n");
pcap_close(pcapData.handle);
exit(1);
}while (1) {
    menü_anzeigen();
    scanf("%d", &auswahl);
    getchar();

    switch (auswahl) {
        case 1: {
            printf("Bitte geben Sie die Nachricht ein: ");
            bzero(buffer, MAX_BUFFER);
            fgets(buffer, MAX_BUFFER - 1, stdin);

            n = write(sockfd, buffer, strlen(buffer));
            if (n < 0) {
                fehler("FEHLER beim Schreiben auf den Socket");
            } else {
                FILE *log = fopen(LOG_FILE, "a");
                if (log != NULL) {
                    fputs(buffer, log);
                    fclose(log);
                } else {
                    perror("Konnte Log-Datei nicht öffnen");
                }
            }
            break;
        }
        case 2: {
            printf("Bitte geben Sie die Nachricht ein: ");
            bzero(buffer, MAX_BUFFER);
            fgets(buffer, MAX_BUFFER - 1, stdin);

            int udpsockfd;
            struct sockaddr_in udp_serv_addr;

            udpsockfd = socket(AF_INET, SOCK_DGRAM, 0);
            if (udpsockfd < 0) {
                fehler("FEHLER beim Öffnen des UDP-Sockets");
            }

            bzero((char *)&udp_serv_addr, sizeof(udp_serv_addr));
            udp_serv_addr.sin_family = AF_INET;
            bcopy((char *)server->h_addr_list[0], (char *)&udp_serv_addr.sin_addr.s_addr, server->h_length);
            udp_serv_addr.sin_port = htons(portno);

            n = sendto(udpsockfd, buffer, strlen(buffer), 0, (struct sockaddr *)&udp_serv_addr, sizeof(udp_serv_addr));
            if (n < 0) {
                fehler("FEHLER beim Schreiben auf den UDP-Socket");
            }

            close(udpsockfd);

            break;
        }
        case 3: {
            if (pthread_create(&pcapThread, NULL, netzwerkverkehr_aufzeichnen, (void *)&pcapData) != 0) {
                fprintf(stderr, "FEHLER beim Erstellen des Pcap-Threads\n");
            }
            pthread_join(pcapThread, NULL);
            break;
        }
        case 4: {
            FILE *log = fopen(LOG_FILE, "r");
            if (log != NULL) {
                while (fgets(buffer, MAX_BUFFER, log)) {
                    printf("%s", buffer);
                }
                fclose(log);
            } else {
                perror("Konnte Log-Datei nicht öffnen");
            }
            break;
        }
        case 5: {
            close(sockfd);
            printf("Verbindung beendet\n");
            exit(0);
        }
        default: {
            printf("Unbekannte Auswahl, bitte versuchen Sie es erneut.\n");
        }
    }
}

return 0;
}

